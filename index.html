<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RealPage Collusion Dashboard</title>
  <!-- Favicon -->
  <link rel="icon" type="image/png" href="photos/berkeleyischool-logo-vertical-blue-sm.png">
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
  <!-- Custom Styles -->
  <link rel="stylesheet" href="style.css" />
  <style>
    /* Sidebar styles */
    @media (min-width: 769px) {
      #sidebar-wrapper {
        position: fixed;
        top: 0;
        left: 0;
        height: 100vh;
        width: 250px;
      }

      #page-content-wrapper {
        margin-left: 250px;
      }

      #menu-toggle {
        display: none;
      }

      nav.navbar.fixed-top {
        display: none;
      }
    }

    /* Full-width content sections */
    .section {
      width: 100%;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      scroll-snap-align: start;
      transition: opacity 0.6s ease-out, transform 0.6s ease-out;
      opacity: 0;
      transform: translateY(30px);
      padding: 20px;
    }

    .section.in-view {
      opacity: 1;
      transform: translateY(0);
    }

    /* Adjusted chart container height for readability */
    canvas {
      width: 100%;
      height: auto;
      max-height: 700px;
    }
  </style>
  <!-- Defer non-critical scripts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
  <!-- Chart.js Annotation Plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js" defer></script>
</head>

<body>
  <div class="d-flex" id="wrapper">
    <!-- Sidebar -->
    <div class="bg-light border-end" id="sidebar-wrapper">
      <div class="sidebar-heading text-center py-4">
        <img src="photos/berkeleyischool-logo-vertical-blue-sm.png" alt="UC Berkeley School of Information">
        <h2 class="mids-capstone">MIDS Capstone: <strong>RealPage Collusion Dashboard</strong></h2>
      </div>
      <div class="list-group list-group-flush">
        <a href="index.html" class="list-group-item list-group-item-action bg-light active">Homepage</a>
        <a href="about.html" class="list-group-item list-group-item-action bg-light">About</a>
        <a href="data-dictionary.html" class="list-group-item list-group-item-action bg-light">Data Dictionary</a>
        <a href="interactive-map.html" class="list-group-item list-group-item-action bg-light">Interactive Map</a>
        <a href="key-findings.html" class="list-group-item list-group-item-action bg-light">Key Findings</a>
        <a href="demo.html" class="list-group-item list-group-item-action bg-light">Try It Yourself: Interactive
          Modeling</a>
        <a href="contact-us.html" class="list-group-item list-group-item-action bg-light">Contact Us</a>
      </div>
      <div class="p-3">
        <a href="research-paper.pdf" target="_blank" class="btn btn-primary w-100">View Research Paper</a>
      </div>
    </div>
    <!-- /#sidebar-wrapper -->

    <!-- Page Content -->
    <div id="page-content-wrapper">
      <nav class="navbar navbar-expand-lg navbar-light bg-white border-bottom mobile-only">
        <div class="container-fluid">
          <button class="btn btn-secondary" id="menu-toggle">MIDS Capstone, Spring 2025: RealPage Collusion
            Dashboard</button>
        </div>
      </nav>

      <!-- Introduction Section -->
      <section id="introduction" class="section in-view">
        <div class="w-100 text-center px-4">
          <h1 class="display-1 fw-bold">
            Is <span class="highlight-primary">Algorithmic Pricing</span> Raising Your <span
              class="highlight-primary">Rent?</span>
          </h1>
          <h2 class="display-5 mt-3">A Data-Driven Investigation</h2>

          <p class="lead mt-4">
            RealPage's software lets landlords share secret pricing data, coordinating rent hikes instead of competing
            for tenants. The result? <span class="highlight-secondary">Higher rents, fewer concessions</span>, and no
            real choice
            for renters.
          </p>

          <p class="lead">
            <span class="highlight-secondary">Landlords aren't setting prices—an algorithm is.</span> RealPage collects
            and analyzes private rent data from competitors, then recommends price hikes landlords follow almost
            automatically. This isn't competition—it's algorithmic price-fixing.
          </p>

          <p class="lead">
            This isn't just bad for renters—it's bad for the market.
            <span class="highlight-secondary">RealPage controls 80% of the apartment pricing software industry</span>,
            creating a monopoly that locks landlords in and locks renters out of fair pricing.
          </p>

          <p class="lead">
            When landlords collude, <span class="highlight-secondary">renters lose.</span> Lawsuits are underway, but
            millions of renters have already paid the price. Housing should be a competitive market—not a rigged game.
          </p>

          <div class="row">
            <div class="col-xs-12 col-md-6 col-lg-4 d-flex justify-content-center">
              <div class="card  text-center" style="width: 18rem;">
                <div class="card-body">
                  <h1 class="card-title">$1,803</h1>
                  <p class="card-text"> <a href="https://nlihc.org/oor/state/dc" class="card-link">DC's Fair Market Rent
                      (1 Bedroom Apartment, $2,045 for 2 bedrooms )</a></p>
                </div>
              </div>
            </div>
            <div class="col-xs-12 col-md-6 col-lg-4 d-flex justify-content-center">
              <div class="card  text-center" style="width: 18rem;">
                <div class="card-body">
                  <h1 class="card-title">$2,053</h1>
                  <p class="card-text"> <a
                      href="https://www.zillow.com/rental-manager/market-trends/washington-dc/?propertyTypes=apartment-condo"
                      class="card-link">DC's Average Rent (All Apartments)</a></p>
                </div>
              </div>
            </div>
            <div class="col-xs-12 col-md-6 col-lg-4 d-flex justify-content-center">
              <div class="card  text-center" style="width: 18rem;">
                <div class="card-body">
                  <h1 class="card-title"><span class="highlight-primary">$2,150</span></h1>
                  <p class="card-text"> <a href="data-dictionary.html" class="card-link">RealPages's Average Rent (DC,
                      All Apartments)</a></p>
                </div>
              </div>
            </div>
          </div>


          <!-- Jump to Key Findings -->
          <div class="mt-5">
            <a href="#keyFindings" class="btn btn-primary btn-lg">Jump to Key Findings</a>
          </div>

          <!-- Scroll Down Arrow -->
          <p class="mt-4">Or scroll down to learn how Algorithmic Collusion works</p>
          <div class="scroll-indicator">
            <a href="#algorithmicCollusion">
              <span class="arrow arrow-down"></span>
            </a>
          </div>
        </div>
      </section>
      <!-- What is Algorithmic Collusion -->
      <hr class="mt-5" id="algorithmicCollusion">
      <section class="section">
        <div class="mt-5">
          <div class="container-fluid py-2">
            <h1 class="display-3 text-center ">How Algorithmic Collusion in Rent Pricing Works</h1>
            <!-- Slider Container: Only one card is visible at a time -->
            <div class="card-slider" style="position: relative; overflow: hidden;">
              <!-- The inner container that slides -->
              <div class="d-flex flex-row flex-nowrap transition-container">
                <div class="card" style="min-width: 100%;">
                  <div class="card-body">
                    <h3 class="card-title">What Are Rent-Setting Algorithms?</h3>
                    <p class="card-text">
                      Landlords today often use computer programs (algorithms) to help decide how much rent to charge.
                      An algorithm is a set of rules or a software tool that looks at various factors (like apartment
                      size,
                      location, demand, time of year) and then recommends a rent price. Companies offer these
                      rent-setting
                      algorithms to landlords as a way to maximize their profits. Instead of manually researching the
                      market
                      or guessing, a landlord can rely on the software’s suggestion for the “optimal” rent.
                      In fact, many big property management firms use these tools for
                      <a
                        href="https://www.ftc.gov/business-guidance/blog/2024/03/price-fixing-algorithm-still-price-fixing#:~:text=Meanwhile%2C%20landlords%20increasingly%20use%20algorithms,to%20vote%20with%20their%20feet">
                        tens of millions of apartments
                      </a> across the country.
                      The goal is usually to charge the highest rent that people are willing to pay.
                      One executive at a rent pricing company even admitted their software encouraged rent hikes that
                      managers
                      <a
                        href="https://www.propublica.org/article/yieldstar-rent-increase-realpage-rent#:~:text=%E2%80%9CI%20think%20it%E2%80%99s%20driving%20it%2C,%E2%80%9D">
                        wouldn’t normally dare to do on their own
                      </a>.
                    </p>
                  </div>
                </div>

                <div class="card" style="min-width: 100%;">
                  <div class="card-body">
                    <h3 class="card-title">How Do These Algorithms Track Competitors’ Prices?</h3>
                    <p class="card-text">
                      These rent algorithms don’t set prices in a vacuum – they pay close attention to what other
                      landlords are charging. The
                      <a
                        href="https://www.justice.gov/archives/opa/pr/justice-department-sues-realpage-algorithmic-pricing-scheme-harms-millions-american-renters#:~:text=The%20complaint%C2%A0alleges%20that%20RealPage%20contracts,to%20attract%20renters%20based%20on">
                        software often gathers data
                      </a> from nearby similar apartments to see the going rates. In some cases, companies even collect
                      private
                      pricing info from many landlords and
                      <a
                        href="https://www.justice.gov/archives/opa/pr/justice-department-sues-realpage-algorithmic-pricing-scheme-harms-millions-american-renters#:~:text=The%20complaint%C2%A0alleges%20that%20RealPage%20contracts,to%20attract%20renters%20based%20on">
                        feed it into a shared system
                      </a>.
                      Using all this market data, the algorithm adjusts its recommendations. For example, if the
                      apartment complex across the street bumps up its rent for a one-bedroom unit, the algorithm at
                      your building
                      might notice that and suggest you could raise your rent too. Conversely, if a competitor lowers
                      prices or offers a special deal, the software will know and might respond (perhaps telling your
                      landlord
                      to also slightly lower rent, or to hold firm if it predicts the competitor’s drop is temporary).
                      This is
                      similar to how airlines or hotels set prices: constantly monitoring what others are doing and then
                      tweaking their own prices accordingly. The key point is that landlords’ pricing software is always
                      watching the
                      competition and reacting to it, much faster and more consistently than any human landlord could.
                    </p>
                  </div>
                </div>
                <div class="card" style="min-width: 100%;">
                  <div class="card-body">
                    <h3 class="card-title">When Algorithms Collude (Unintended Collusion)</h3>
                    <p class="card-text">
                      “Collusion” is when businesses secretly cooperate instead of competing, usually to keep prices
                      high.
                      Normally, collusion is illegal – for instance, landlords aren’t allowed to sit in a room together
                      and
                      agree, “Let’s all charge $1,500 for one-bedroom apartments and not go lower.” But with algorithms,
                      something similar can happen without anyone explicitly plotting. Here’s how: Imagine a city where
                      multiple
                      major landlords are all using the same or similar rent-setting algorithm. Because they’re using
                      the same
                      tool (or tools that work in similar ways), they end up following the same playbook. If the
                      algorithm sees
                      strong demand in the city, it might tell every landlord using it to keep rents high. If one
                      landlord’s
                      software raises rent, the others’ software takes note and may raise their rents, too. None of
                      these
                      landlords called each other on the phone to agree on a price, but in effect their software is
                      coordinating
                      their moves.
                    </p>
                    <p class="card-text">
                      This phenomenon is sometimes called “algorithmic collusion” or tacit collusion. It’s “tacit” or
                      unintended in the sense that no person sat down and said “let’s form a cartel.” Yet the outcome –
                      uniformly
                      high rents – is similar to what you’d see if there was a secret cartel. Regulators have noticed
                      this
                      problem. The U.S. Department of Justice, for example, alleges that a popular rent pricing
                      algorithm allowed
                      landlords to “align their rents” and
                      <a
                        href="https://www.justice.gov/archives/opa/pr/justice-department-sues-realpage-algorithmic-pricing-scheme-harms-millions-american-renters#:~:text=way%20to%20scheme%20with%20landlords,%E2%80%9D">
                        avoid competing with each other
                      </a>.
                      Essentially, the software became a middleman that let landlords stick to a high-price strategy
                      together.
                      One former FTC official gave a useful illustration: she said to imagine replacing the word
                      “algorithm” with
                      “a guy named Bob.” If all the landlords gave Bob their private pricing information and Bob told
                      each of them
                      what rent to charge, that would clearly be
                      <a
                        href="https://www.propublica.org/article/yieldstar-rent-increase-realpage-rent#:~:text=She%20suggested%20substituting%20%E2%80%9Ca%20guy,everywhere%20the%20word%20algorithm%20appears">
                        illegal collusion
                      </a>. If it’s not OK for a person to coordinate prices like that, it’s also not OK when a computer
                      program
                      does it. In short, using fancy software doesn’t magically make price-fixing legal. But many
                      landlords may
                      not even realize this is what’s happening – they just see the software’s recommendations and
                      follow along.
                      The result is a “silent agreement” of high prices: unintended by any single landlord, but very
                      real for renters
                      who have to pay those prices.
                    </p>
                  </div>
                </div>
                <div class="card" style="min-width: 100%;">
                  <div class="card-body">
                    <h3 class="card-title">Impact on Renters: Rising Costs and Fewer Options</h3>
                    <ul class="list-group list-group-flush">
                      <li class="list-group-item">
                        Higher Rents Across the Board: When landlords coordinate (even unintentionally) on high prices,
                        renters lose the benefit of shopping around. One analysis by the White House’s economic advisers
                        found that algorithmic rent pricing led to renters paying about $70 more per month on average​.
                        That’s roughly a 4% increase in rent – solely due to the pricing software’s effects – which
                        adds up to over $800 extra per year for the same apartment. In 2023 alone, renters nationwide
                        paid an estimated $3.8 billion more in rent <a
                          href="https://www.multifamilydive.com/news/price-setting-algorithm-non-public-information-legislation-bill/739836/#:~:text=Under%20the%20bill%E2%80%99s%20definition%2C%20sharing,8%20billion%20in%202023">
                          because of these algorithm-driven pricing practices​
                        </a>
                      </li>
                      <li class="list-group-item">Reduced Affordability and Choice: With nearly all landlords following
                        similar high-price signals, renters can’t find a “cheap” option – every nearby landlord is
                        charging top dollar. This makes housing far less affordable. Already, about half of renters in
                        the U.S. spend over
                        <a
                          href="https://www.ftc.gov/business-guidance/blog/2024/03/price-fixing-algorithm-still-price-fixing#:~:text=The%20agencies%E2%80%99%20work%20in%20this,thirds%20of%20January%20inflation">
                          30% of their income on rent and utilities
                        </a>
                        (a common benchmark for affordability).​ If rents are inflated due to algorithmic coordination,
                        more people will be pushed past that
                        30% threshold. Renters might have to cut other expenses, move farther away, or live with
                        roommates or family just to make ends meet. In other words, the cost burden on renters
                        increases, and those with limited incomes are hurt the most. High, synchronized rents can price
                        some people out of certain neighborhoods entirely, contributing to housing crises and
                        instability for families.
                      </li>
                    </ul>
                  </div>
                </div>
                <div class="card" style="min-width: 100%;">
                  <div class="card-body">
                    <h3 class="card-title">An Alternative Example: Buying Gas</h3>
                    <p class="card-text">
                      Think of it like this: imagine all the gas stations in town used the same automatic pricing app.
                      Each gas station owner types in some data, and the app tells them what price to put on the pump.
                      The
                      app also checks what all the other gas stations are charging. Now, if one station tries to lower
                      its
                      price to attract more customers, the app will notice and will likely tell the other stations to
                      lower their prices a bit too, so that first station doesn’t get much of an edge. On the flip side,
                      if the app sees that one station can successfully raise prices (say, during a big event or
                      holiday),
                      it will prompt the others to raise their prices as well. In the end, all the gas stations end up
                      with pretty similar, higher prices. No owner ever called up another to agree on a price, but
                      because
                      they all followed the same software, the outcome is as if they had a gentle agreement not to
                      compete. Drivers in that town would find that no matter which gas station they go to, the price
                      per
                      gallon is high and nearly identical.
                    </p>
                    <p class="card-text">This is essentially what happens with algorithmic rent pricing. All the
                      landlords
                      using the same (or similar) rent algorithms end up moving prices in unison, like a flock of birds
                      turning together. Renters are like the drivers looking for cheaper gas – they discover that every
                      apartment they visit has high rent, because the landlords’ software has guided them all to keep
                      rents up. It’s as if the landlords had a friendly pact to not undercut each other, even though
                      they
                      never spoke directly. The analogy shows why this is a problem: when businesses should be competing
                      on price but instead start acting in sync (thanks to an algorithm), consumers lose out. In rental
                      housing, that means families paying more for shelter and struggling with affordability, all
                      because
                      of a behind-the-scenes algorithm that unintentionally encouraged a form of collusion.
                    </p>
                  </div>
                </div>
                <div class="card" style="min-width: 100%;">
                  <div class="card-body">
                    <h3 class="card-title">Algorithmic Collusion Simulation
                    </h3>
                    <button id="restartBtn" class="btn btn-primary btn-lg float-start"
                      onclick="restartSimulation()">Restart
                      Simulation</button>

                    <div class="container-rentsim">
                      <div class="bar-rentsim" id="bar1" style="height: 200px">
                        <div class="price" id="price1">$1000</div>
                      </div>
                      <div class="bar-rentsim" id="bar2" style="height: 220px">
                        <div class="price" id="price2">$1100</div>
                      </div>
                      <div class="bar-rentsim" id="bar3" style="height: 210px">
                        <div class="price" id="price3">$1050</div>
                      </div>
                      <div class="bar-rentsim" id="bar4" style="height: 190px">
                        <div class="price" id="price4">$950</div>
                      </div>
                    </div>

                    <script>
                      // Number of landlord agents.
                      var numAgents = 4;
                      // Initial prices for each landlord.
                      var prices = [1000, 1100, 1050, 950];
                      // Global market indicator that influences all prices.
                      var globalMarket = 1000;
                      // How much the global market can change each update.
                      var volatility = 50;

                      // Update the simulation every second.
                      function updatePrices() {
                        // Global market performs a random walk.
                        var change = (Math.random() - 0.5) * volatility;
                        globalMarket += change;

                        // Each landlord's algorithm adjusts its price toward the global indicator.
                        for (var i = 0; i < numAgents; i++) {
                          prices[i] = prices[i] + 0.5 * (globalMarket - prices[i]);
                        }

                        // Update the visual bars and price labels.
                        for (var i = 0; i < numAgents; i++) {
                          var bar = document.getElementById("bar" + (i + 1));
                          var priceLabel = document.getElementById("price" + (i + 1));
                          // Scale the bar height for visualization purposes.
                          // (Higher price yields a taller bar.)
                          var height = prices[i] / 5;
                          bar.style.height = height + "px";
                          priceLabel.innerHTML = "$" + Math.round(prices[i]);
                        }
                      }

                      // Reset global market and prices to their initial values.
                      function restartSimulation() {
                        globalMarket = 1000;
                        prices = [1000, 1100, 1050, 950];
                        // Update the visual bars immediately.
                        for (var i = 0; i < numAgents; i++) {
                          var bar = document.getElementById("bar" + (i + 1));
                          var priceLabel = document.getElementById("price" + (i + 1));
                          var height = prices[i] / 5;
                          bar.style.height = height + "px";
                          priceLabel.innerHTML = "$" + Math.round(prices[i]);
                        }
                      }

                      // Repeat the update in a loop.
                      setInterval(updatePrices, 2000);
                    </script>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <!-- Navigation Buttons -->
        <button class="nav-button prev btn btn-primary btn-lg" id="prevButton" onclick="slidePrev()"
          style="position: absolute; left: 10px; transform: translateY(-50%);">
          Prev
        </button>
        <button class="nav-button next btn btn-primary btn-lg" id="nextButton" onclick="slideNext()"
          style="position: absolute; right: 10px; transform: translateY(-50%);">
          Next
        </button>
        <!-- Scroll Down Arrow -->
        <p class="mt-4">Scroll down to learn how we identified Realpage properties</p>
        <div class="scroll-indicator">
          <a href="#identificationMethodsHR">
            <span class="arrow arrow-down"></span>
          </a>
        </div>
      </section>

      <!-- JavaScript for sliding functionality -->
      <script>
        document.addEventListener("DOMContentLoaded", function () {
          const container = document.querySelector(".transition-container");
          const cards = container.querySelectorAll(".card");
          const prevButton = document.getElementById("prevButton");
          const nextButton = document.getElementById("nextButton");
          let currentIndex = 0;
          let cardWidth = cards[0].offsetWidth;

          // Update navigation buttons preview text and visibility
          function updateButtons() {
            if (currentIndex < cards.length - 1) {
              const nextTitle = cards[currentIndex + 1].querySelector(".card-title").innerText;
              nextButton.innerText = "Next: " + nextTitle;
              nextButton.style.display = "block";
            } else {
              nextButton.style.display = "none";
            }

            if (currentIndex > 0) {
              const prevTitle = cards[currentIndex - 1].querySelector(".card-title").innerText;
              prevButton.innerText = "Prev: " + prevTitle;
              prevButton.style.display = "block";
            } else {
              prevButton.style.display = "none";
            }
          }

          // Slide to the next card
          window.slideNext = function () {
            if (currentIndex < cards.length - 1) {
              currentIndex++;
              container.style.transform = "translateX(-" + (cardWidth * currentIndex) + "px)";
              updateButtons();
            }
          };

          // Slide to the previous card
          window.slidePrev = function () {
            if (currentIndex > 0) {
              currentIndex--;
              container.style.transform = "translateX(-" + (cardWidth * currentIndex) + "px)";
              updateButtons();
            }
          };

          // Update button previews on load and when window is resized
          updateButtons();
          window.addEventListener("resize", function () {
            cardWidth = cards[0].offsetWidth;
            container.style.transform = "translateX(-" + (cardWidth * currentIndex) + "px)";
          });
        });
      </script>
      <hr class="mt-5" id="identificationMethodsHR">
      <!-- Section A: Identifying RealPage-Managed Properties -->
      <section class="section" id="identificationMethods">
        <div class="text-center w-100">
          <h1>What factors into rent? </h1>
          <h5>and how does RealPage compare?</h5>
          <p>
            First off: Location, location, location. Some cities are more expensive than others due to higher paying
            jobs, the size of the city, greater density, and other factors.
          </p>
          <div style="display: flex; flex-direction: column; gap: 20px;">
            <canvas id="rentComparablesChart"></canvas>
            <canvas id="yearBuiltVolumeChart"></canvas>

            
          </div>
        </div>
      </section>

      <div class="content">
        <!-- Section 1: Contextualizing Rent -->
        <section id="whatIsRent" class="section">
          <div class="text-center w-100">
            <h1>Contextualizing Rent: The Role of Housing Supply</h1>
            <p>
              Rent isn't just a monthly expense—it reflects the market's housing supply. By examining average unit
              counts as a proxy for available housing, we set the stage to explore how algorithmic pricing might
              influence these fundamentals.
            </p>
            <canvas id="explanatoryChart"></canvas>
          </div>
        </section>

        <!-- Section 2: Tracing Rent Dynamics -->
        <section id="diffinDiff" class="section">
          <div class="text-center w-100">
            <h1>Tracing Rent Dynamics: Pre‑ and Post‑RealPage Adoption</h1>
            <p>
              In this section, we use a difference‑in‑difference framework to explore how rent changes evolve before and
              after RealPage's entry. This method helps us isolate the impact of algorithmic pricing on rent inflation.
            </p>
            <canvas id="diffinDiffChart"></canvas>
          </div>
        </section>

        <!-- Section 3: Uncovering Price Adjustments -->
        <section id="rentComparison" class="section">
          <div class="text-center w-100">
            <h1>Current vs. Historical Rents: Uncovering Price Adjustments</h1>
            <p>
              By comparing current market rents with historical asking rents across property managers, we assess whether
              RealPage-managed properties exhibit distinct price adjustments that might indicate algorithm-driven
              inflation.
            </p>
            <canvas id="rentComparisonChart"></canvas>
          </div>
        </section>

        <!-- Section 4: Occupancy Trends -->
        <section id="occupancyTrends" class="section">
          <div class="text-center w-100">
            <h1>Occupancy Trends Amidst Market Shifts</h1>
            <p>
              Tracking occupancy rates over time reveals how tenants respond to changing rent levels. This section
              explores whether higher RealPage adoption correlates with altered occupancy trends—hinting at broader
              market impacts.
            </p>
            <canvas id="occupancyChart"></canvas>
          </div>
        </section>

        <!-- Section 5: Correlation & Potential Collusion -->
        <section id="correlationTests" class="section">
          <div class="text-center w-100">
            <h1>Testing the Link: RealPage Adoption & Rent Inflation</h1>
            <p>
              We directly test whether algorithmic pricing is associated with inflated rents. By correlating historical
              ask rents with RealPage's market presence, this scatter chart aims to reveal statistical patterns
              suggestive of collusive behavior.
            </p>
            <canvas id="correlationChart"></canvas>
            <!-- Add Model graphs here -->
          </div>
        </section>

        <!-- Section 6: Key Findings & Policy Implications -->
        <section id="keyFindings" class="section">
          <div class="text-center w-100">
            <h1>Key Findings & Policy Implications</h1>
            <p>
              Our analysis reveals a significant association between RealPage's market presence and rent dynamics. The
              guided journey through housing supply, rent adjustments, occupancy rates, and robust counterfactual tests
              suggests that algorithmic pricing may contribute to rent inflation.
            </p>
            <p><strong>Policy Implications:</strong></p>
            <ul>
              <li>Regulators and policymakers should consider the impact of pricing technologies on housing
                affordability.</li>
              <li>Enhanced transparency and oversight might be needed to ensure fair competition in rental markets.</li>
              <li>Stakeholders—from tenants to property managers—could benefit from clearer insights into how technology
                drives market outcomes.</li>
            </ul>
            <p>
              These findings underscore the need for further investigation and proactive policy responses in an era
              marked by rising housing instability and technological disruption.
            </p>
          </div>
        </section>
      </div>

      <footer class="bg-light text-center py-3 border-top w-100">
        <p class="mb-0">
          &copy; 2025 RealPage Collusion Dashboard &mdash;
          <a href="privacy.html">View Full Privacy Policy</a>
        </p>
      </footer>
    </div>
    <!-- /#page-content-wrapper -->
  </div>

  <!-- Inline Script: Initialize Charts and Load Data -->
  <script defer>
    let charts = {};
    let csvData = [];
    let chartsInitialized = {
      whatIsRent: false,
      diffinDiff: false,
      rentComparison: false,
      occupancyTrends: false,
      correlationTests: false,
      benchmarkComparison: false,
      syntheticControl: false,
      alternativeMeasures: false,
      identificationMethods: false
    };

    // Section metrics for chart labels
    const sectionMetrics = {
      whatIsRent: { metric: 'unitcount', label: 'Housing Supply Proxy: Avg Unit Count' },
      diffinDiff: { metric: 'MPF-ANN-RENT-CHG', label: 'Impact of Algorithmic Pricing on Rent Change' },
      rentComparison: { metric1: 'MPF-RENT', metric2: 'MPF-HIST-ASK-RENT', label: 'Current vs Historical Rents' },
      occupancyTrends: { metric: 'MPF-OCC', label: 'Occupancy Trends Amid Price Changes' },
      correlationTests: { metric: 'MPF-HIST-ASK-RENT', label: 'Correlation: RealPage Adoption & Historical Ask Rent' },
      identificationMethods: { metric: 'unitcount', label: 'Identifying RealPage-Managed Properties' }
    };

    // Helper for color selection
    function getColorForHero(hero) {
      if (hero.toLowerCase() === "realpage") {
        return 'rgba(54, 162, 235, 1)';
      } else if (hero.toLowerCase() === "google") {
        return 'rgba(255, 159, 64, 1)';
      } else {
        return 'rgba(128, 128, 128, 1)';
      }
    }

    // Aggregation functions for charts
    function aggregateByStateGrouped(metric) {
      let grouped = {};
      csvData.forEach(row => {
        let state = row.state;
        let hero = row.heroSource;
        if (state && hero) {
          if (!grouped[state]) grouped[state] = {};
          if (!grouped[state][hero]) grouped[state][hero] = { sum: 0, count: 0 };
          grouped[state][hero].sum += parseFloat(row[metric]) || 0;
          grouped[state][hero].count += 1;
        }
      });
      let labels = Object.keys(grouped).sort();
      let heroSet = new Set();
      Object.values(grouped).forEach(heroObj => {
        Object.keys(heroObj).forEach(hero => heroSet.add(hero));
      });
      let heroSources = Array.from(heroSet);
      let datasets = heroSources.map(hero => {
        let data = labels.map(state => {
          if (grouped[state][hero]) {
            let agg = grouped[state][hero];
            return agg.sum / agg.count;
          } else {
            return null;
          }
        });
        return {
          label: hero,
          data: data,
          fill: false,
          borderColor: getColorForHero(hero),
          backgroundColor: 'transparent',
          tension: 0.1,
          borderWidth: 1
        };
      });
      return { labels, datasets };
    }

    function aggregateByYearGrouped(metric) {
      let grouped = {};
      csvData.forEach(row => {
        let year = row.yearBuilt;
        let hero = row.heroSource;
        if (year && hero) {
          if (!grouped[year]) grouped[year] = {};
          if (!grouped[year][hero]) grouped[year][hero] = { sum: 0, count: 0 };
          grouped[year][hero].sum += parseFloat(row[metric]) || 0;
          grouped[year][hero].count += 1;
        }
      });
      let labels = Object.keys(grouped).sort();
      let heroSet = new Set();
      Object.values(grouped).forEach(heroObj => {
        Object.keys(heroObj).forEach(hero => heroSet.add(hero));
      });
      let heroSources = Array.from(heroSet);
      let datasets = heroSources.map(hero => {
        let data = labels.map(year => {
          if (grouped[year][hero]) {
            let agg = grouped[year][hero];
            return agg.sum / agg.count;
          } else {
            return null;
          }
        });
        return {
          label: hero,
          data: data,
          fill: false,
          borderColor: getColorForHero(hero),
          backgroundColor: 'transparent',
          tension: 0.1,
          borderWidth: 1
        };
      });
      return { labels, datasets };
    }

    function aggregateDualByYearByHero(metric1, metric2) {
      let grouped = {};
      csvData.forEach(row => {
        let year = row.yearBuilt;
        let hero = row.heroSource;
        if (year && hero) {
          if (!grouped[year]) grouped[year] = {};
          if (!grouped[year][hero]) {
            grouped[year][hero] = { metric1Sum: 0, metric1Count: 0, metric2Sum: 0, metric2Count: 0 };
          }
          grouped[year][hero].metric1Sum += parseFloat(row[metric1]) || 0;
          grouped[year][hero].metric1Count += 1;
          grouped[year][hero].metric2Sum += parseFloat(row[metric2]) || 0;
          grouped[year][hero].metric2Count += 1;
        }
      });
      let years = Object.keys(grouped).sort();
      let heroSet = new Set();
      years.forEach(year => {
        for (let hero in grouped[year]) {
          heroSet.add(hero);
        }
      });
      let heroes = Array.from(heroSet);
      let datasets = [];
      heroes.forEach(hero => {
        let data1 = years.map(year => {
          if (grouped[year][hero]) {
            let group = grouped[year][hero];
            return group.metric1Sum / group.metric1Count;
          } else {
            return null;
          }
        });
        datasets.push({
          label: hero + " - Current Rent",
          data: data1,
          borderColor: getColorForHero(hero),
          fill: false,
          tension: 0.1,
          borderWidth: 1,
          borderDash: []
        });
        let data2 = years.map(year => {
          if (grouped[year][hero]) {
            let group = grouped[year][hero];
            return group.metric2Sum / group.metric2Count;
          } else {
            return null;
          }
        });
        datasets.push({
          label: hero + " - Historical Ask Rent",
          data: data2,
          borderColor: getColorForHero(hero),
          fill: false,
          tension: 0.1,
          borderWidth: 1,
          borderDash: [5, 5]
        });
      });
      return { labels: years, datasets };
    }

    // NEW: Define getChartDataGrouped before it's used.
    function getChartDataGrouped(metric, chartType) {
      if (chartType === 'line' || chartType === 'scatter') {
        return aggregateByYearGrouped(metric);
      } else {
        return aggregateByStateGrouped(metric);
      }
    }

    // NEW functions for RealPage share aggregations
    function aggregateRealPageShareByState() {
      let stateData = {};
      csvData.forEach(row => {
        let state = row.state;
        if (state) {
          if (!stateData[state]) {
            stateData[state] = { total: 0, realpageCount: 0 };
          }
          stateData[state].total += 1;
          if (row.heroSource && row.heroSource.toLowerCase() === 'realpage') {
            stateData[state].realpageCount += 1;
          }
        }
      });

      function aggregateRealPageShareByCity() {
        let cityData = {};
        csvData.forEach(row => {
          let city = row.city;
          if (city) {
            if (!cityData[city]) {
              cityData[city] = { total: 0, realpageCount: 0 };
            }
            cityData[city].total += 1;
            if (row.heroSource && row.heroSource.toLowerCase() === 'realpage') {
              cityData[city].realpageCount += 1;
            }
          }
        });
        return cityData;
      }

      // Get state names and sort them based on computed share value (descending)
      let states = Object.keys(stateData);
      states.sort((a, b) => {
        let shareA = stateData[a].realpageCount / stateData[a].total;
        let shareB = stateData[b].realpageCount / stateData[b].total;
        return shareB - shareA; // descending order; use shareA - shareB for ascending order
      });

      let data = states.map(state => {
        let share = stateData[state].realpageCount / stateData[state].total;
        return (share * 100).toFixed(2);
      });

      return {
        labels: states,
        datasets: [{
          label: 'RealPage Share (%)',
          data: data,
          backgroundColor: 'rgba(54, 162, 235, 0.6)',
          borderColor: 'rgba(54, 162, 235, 1)',
          borderWidth: 1
        }]
      };
    }

    function aggregateRealPageShareByYear() {
      let yearData = {};
      csvData.forEach(row => {
        let year = row.yearBuilt;
        if (year) {
          if (!yearData[year]) {
            yearData[year] = { total: 0, realpageCount: 0 };
          }
          yearData[year].total += 1;
          if (row.heroSource && row.heroSource.toLowerCase() === 'realpage') {
            yearData[year].realpageCount += 1;
          }
        }
      });
      let labels = Object.keys(yearData).sort();
      let data = labels.map(year => {
        let share = yearData[year].realpageCount / yearData[year].total;
        return (share * 100).toFixed(2);
      });
      return {
        labels: labels, datasets: [{
          label: 'RealPage Adoption Share (%)',
          data: data,
          fill: false,
          borderColor: 'rgba(255, 99, 132, 1)',
          backgroundColor: 'transparent',
          tension: 0.1,
          borderWidth: 2
        }]
      };
    }

    // Regression helper function for scatterplot
    function computeLinearRegression(dataPoints) {
      let n = dataPoints.length;
      if (n === 0) return null;
      let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
      dataPoints.forEach(pt => {
        sumX += pt.x;
        sumY += pt.y;
        sumXY += pt.x * pt.y;
        sumXX += pt.x * pt.x;
      });
      let slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
      let intercept = (sumY - slope * sumX) / n;
      return { slope: slope, intercept: intercept };
    }

    // Chart initialization function
    function initChart(ctxId, chartType, title, chartData, extraOptions = {}) {
      const ctx = document.getElementById(ctxId).getContext('2d');
      return new Chart(ctx, {
        type: chartType,
        data: {
          labels: chartData.labels,
          datasets: chartData.datasets
        },
        options: Object.assign({
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: 0 },
          interaction: { mode: 'index', intersect: false },
          plugins: {
            tooltip: {
              enabled: true,
              bodyFont: { size: 16 },
              callbacks: {
                label: function (context) {
                  if (chartType === 'scatter') {
                    return 'Year: ' + context.raw.x + ', Value: ' + context.raw.y;
                  } else {
                    return context.dataset.label + ": " + context.parsed.y;
                  }
                }
              }
            },
            legend: { display: true, labels: { font: { size: 16 } } },
            title: { display: true, text: title, font: { size: 18 } }
          },
          scales: {
            x: { ticks: { autoSkip: true, maxTicksLimit: 20, font: { size: 14 } } },
            y: { ticks: { font: { size: 14 } } }
          }
        }, extraOptions)
      });
    }

    // Section Initialization
    function initializeSection(sectionId) {
      if (!chartsInitialized[sectionId]) {
        chartsInitialized[sectionId] = true;
        let chartType, dt;
        switch (sectionId) {
          case "whatIsRent":
            chartType = 'line';
            dt = getChartDataGrouped(sectionMetrics.whatIsRent.metric, chartType);
            charts.whatIsRent = initChart('explanatoryChart', chartType, sectionMetrics.whatIsRent.label, dt);
            break;
          case "diffinDiff":
            chartType = 'line';
            dt = getChartDataGrouped(sectionMetrics.diffinDiff.metric, chartType);
            charts.diffinDiff = initChart('diffinDiffChart', chartType, sectionMetrics.diffinDiff.label, dt, {
              scales: {
                x: { title: { display: true, text: 'Year' }, ticks: { font: { size: 14 } } },
                y: {
                  title: { display: true, text: 'Annual Change in Rent (%)' },
                  ticks: {
                    font: { size: 14 },
                    callback: function (value) {
                      return (value * 100).toFixed(0) + '%'; // Multiply by 100 and append a percent sign
                    }
                  }
                }
              },
              plugins: {
                annotation: {
                  annotations: {
                    line1: {
                      type: 'line',
                      scaleID: 'x', // Reference to your x-axis
                      value: '2017', // Ensure this exactly matches one of your x-axis labels
                      borderColor: 'blue',
                      borderWidth: 2,
                      label: {
                        enabled: true,
                        content: '2017 merger with LRO',
                        position: 'top',
                        backgroundColor: 'blue',
                      }
                    }
                  }
                }
              }
            });
            break;
          case "rentComparison":
            chartType = 'line';
            dt = aggregateDualByYearByHero(sectionMetrics.rentComparison.metric1, sectionMetrics.rentComparison.metric2);
            charts.rentComparison = initChart('rentComparisonChart', chartType, sectionMetrics.rentComparison.label, dt);
            break;
          case "occupancyTrends":
            chartType = 'line';
            dt = getChartDataGrouped(sectionMetrics.occupancyTrends.metric, chartType);
            charts.occupancyTrends = initChart('occupancyChart', chartType, sectionMetrics.occupancyTrends.label, dt,
              {
                scales: {
                  x: { title: { display: true, text: 'Year' }, ticks: { font: { size: 14 } } },
                  y: {
                    title: { display: true, text: 'Occupied Units (%)' },
                    ticks: {
                      font: { size: 14 },
                      callback: function (value) {
                        return (value * 100).toFixed(0) + '%'; // Multiply by 100 and append a percent sign
                      }
                    }
                  }
                }
              }
            );
            break;
          case "correlationTests":
            chartType = 'scatter';
            dt = getChartDataGrouped(sectionMetrics.correlationTests.metric, chartType);
            dt.datasets.forEach((dataset, idx) => {
              dataset.data = dt.labels.map((year, i) => ({ x: parseFloat(year), y: dataset.data[i] }));
            });
            let allDataPoints = dt.datasets[0].data;
            let reg = computeLinearRegression(allDataPoints);
            if (reg) {
              let minX = Math.min(...allDataPoints.map(pt => pt.x));
              let maxX = Math.max(...allDataPoints.map(pt => pt.x));
              let regData = [
                { x: minX, y: reg.slope * minX + reg.intercept },
                { x: maxX, y: reg.slope * maxX + reg.intercept }
              ];
              dt.datasets.push({
                label: 'Regression Line',
                data: regData,
                type: 'line',
                borderColor: 'rgba(0, 0, 0, 0.7)',
                borderDash: [5, 5],
                fill: false,
                pointRadius: 0
              });
            }
            charts.correlation = initChart('correlationChart', chartType, sectionMetrics.correlationTests.label, dt, {
              scales: {
                x: {
                  type: 'linear',
                  position: 'bottom',
                  title: { display: true, text: 'Year' },
                  ticks: {
                    callback: function (value, index, ticks) {
                      return parseInt(value).toString(); // Converts 2,017 to "2017"
                    }
                  }
                },
                y: { beginAtZero: true, title: { display: true, text: sectionMetrics.correlationTests.label } }
              },
              parsing: false
            });
            break;
          case "identificationMethods":
            let geoChartType = 'bar';
            let geoData = aggregateRealPageShareByState();
            charts.geoHeatmap = initChart('geoHeatmapChart', geoChartType, 'Geographic Distribution of Properties using the RealPage Algorithm', geoData);
            let adoptionChartType = 'line';
            let adoptionData = aggregateRealPageShareByYear();
            charts.adoptionTrends = initChart('adoptionTrendsChart', adoptionChartType, 'Time Series of RealPage Adoption Trends', adoptionData);
            break;
        }
      }
    }
    function aggregateUnitCountByYearBuilt(data) {
      const yearGroups = {};
      data.forEach(row => {
        const year = row.yearBuilt;
        const units = parseInt(row.unitcount) || 0;
        if (year) {
          if (!yearGroups[year]) yearGroups[year] = 0;
          yearGroups[year] += units;
        }
      });
      const sortedYears = Object.keys(yearGroups).sort();
      const counts = sortedYears.map(y => yearGroups[y]);
      return {
        labels: sortedYears,
        datasets: [
          {
            label: "Total Unit Count",
            data: counts,
            backgroundColor: "rgba(153, 102, 255, 0.6)",
            borderColor: "rgba(153, 102, 255, 1)",
            borderWidth: 1
          }
        ]
      };
    }
    function aggregateByState() {
      let stateAgg = {};
      csvData.forEach(row => {
        let state = row.state;
        if (state) {
          if (!stateAgg[state]) {
            stateAgg[state] = {
              unitcountSum: 0,
              mpfRpsfSum: 0,
              mpfHistAskRentSum: 0,
              mpfAnnRentChgSum: 0,
              count: 0
            };
          }
          stateAgg[state].unitcountSum += parseFloat(row.unitcount) || 0;
          stateAgg[state].mpfRpsfSum += parseFloat(row["MPF-RPSF"]) || 0;
          stateAgg[state].mpfHistAskRentSum += parseFloat(row["MPF-HIST-ASK-RENT"]) || 0;
          stateAgg[state].mpfAnnRentChgSum += parseFloat(row["MPF-ANN-RENT-CHG"]) || 0;
          stateAgg[state].count += 1;
        }
      });
    }

    function aggregateByYear() {
      let yearAgg = {};
      csvData.forEach(row => {
        let year = row.yearBuilt;
        if (year) {
          if (!yearAgg[year]) {
            yearAgg[year] = {
              unitcountSum: 0,
              mpfRpsfSum: 0,
              mpfHistAskRentSum: 0,
              mpfAnnRentChgSum: 0,
              count: 0
            };
          }
          yearAgg[year].unitcountSum += parseFloat(row.unitcount) || 0;
          yearAgg[year].mpfRpsfSum += parseFloat(row["MPF-RPSF"]) || 0;
          yearAgg[year].mpfHistAskRentSum += parseFloat(row["MPF-HIST-ASK-RENT"]) || 0;
          yearAgg[year].mpfAnnRentChgSum += parseFloat(row["MPF-ANN-RENT-CHG"]) || 0;
          yearAgg[year].count += 1;
        }
      });
    }

    function updateAllCharts() {
      // Optionally refresh charts if data changes.
    }

    document.addEventListener("DOMContentLoaded", function () {
      const sections = document.querySelectorAll('.section');
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('in-view');
            initializeSection(entry.target.id);
          } else {
            entry.target.classList.remove('in-view');
          }
        });
      }, { threshold: 0.4 });
      sections.forEach(section => observer.observe(section));
    });

    document.addEventListener("DOMContentLoaded", function () {
      fetch('https://rpc-webpage.s3-accelerate.amazonaws.com/cbsa_data.csv')
        .then(response => response.text())
        .then(csvText => {
          Papa.parse(csvText, {
            header: true,
            complete: function (results) {
              csvData = results.data;
              aggregateByState();
              aggregateByYear();
              updateAllCharts();
            }
          });
        })
        .catch(error => console.error("Error loading CSV data:", error));
    });

    document.addEventListener("DOMContentLoaded", function () {
      const menuToggle = document.getElementById("menu-toggle");
      const wrapper = document.getElementById("wrapper");
      menuToggle.addEventListener("click", () => {
        wrapper.classList.toggle("toggled");
      });
    });

    document.addEventListener("DOMContentLoaded", function () {
      const csvString = `City,CBSASub24,HUD,Realpage,Zillow,RealPageMarketShare,Avg of Rents
"Santa Cruz-Watsonville, CA",42100,3388.65,3452.15,3016.74,9.296953948,3286
"San Jose-Sunnyvale-Santa Clara, CA",41940,3099.39,2899.41,3071.1,,3023
"San Luis Obispo-Paso Robles-Arroyo Grande, CA",42020,1808,2884.5,2427.22,,2373
"San Diego-Carlsbad, CA",41740,2499.43,2821.4,2736.57,,2686
"Oxnard-Thousand Oaks-Ventura, CA",37100,2289.04,2615.92,2708.02,17.16353646,2538
"Providence-Fall River, RI-MA",39300,1494.79,2492.5,1959.4,,1982
"Santa Maria-Santa Barbara, CA",42200,2598.81,2492.15,2858.26,5.187820844,2650
"Santa Rosa, CA",42220,1803.8,2467.88,2403.8,,2225
"Chicago-Joliet-Naperville, IL",16980,1745.78,2462.07,2001.53,,2070
"Washington-Arlington-Alexandria, DC-VA-MD",47900,2194.89,2454.56,2265.5,,2305
"Ithaca, NY",27060,1519.33,2382.75,2035.04,6.664101578,1979
"Utica-Rome, NY",46540,963.42,2377,1282.85,,1541
"Burlington-South Burlington, VT",15540,1501.65,2374,1934.22,,1937
"Binghamton, NY",13780,999.18,2361,1099.56,,1487
"Salinas, CA",41500,2637.18,2288,2330.56,9.897201171,2419
"Boulder, CO",14500,1765.29,2239.82,2099.85,19.18003843,2035
"Naples-Immokalee-Marco Island, FL",34940,1696.37,2183.8,2446.48,,2109
"Worcester, MA",49340,1560,2169.94,2028.76,,1920
"Riverside-San Bernardino-Ontario, CA",40140,1976.63,2169.49,2290.14,14.42517463,2145
"Charlottesville, VA",16820,1517.12,1939.76,1741.65,5.896602659,1733
"East Stroudsburg, PA",20700,1255.87,1934.5,1599.36,,1597
"Charleston-North Charleston, SC",16700,1758.68,1928.97,1831.74,23.75321054,1840
"Flagstaff, AZ",22380,1753.24,1916.1,1911.58,1.747602846,1860
"Philadelphia-Camden-Wilmington, PA-NJ-DE-MD",37980,1662.61,1903.86,1808.23,7.781512711,1792
"Sacramento--Roseville--Arden-Arcade, CA",40900,1907.95,1884.46,1996.04,,1929
"Hartford-West Hartford-East Hartford, CT",25540,1386.68,1882.89,1775.64,,1682
"Denver-Aurora-Lakewood, CO",19740,1886.25,1851.64,1789.95,,1843
"Tampa-St. Petersburg-Clearwater, FL",45300,1810.25,1851.11,1866.88,19.02432447,1843
"Santa Fe, NM",42140,1406.55,1849.36,1888.26,10.78369906,1715
"Bellingham, WA",13380,1399.86,1835.41,1690.23,,1642
"Visalia-Porterville, CA",47300,1145.22,1828.83,1315.27,,1430
"Bend-Redmond, OR",13460,1342.73,1826.96,1804.8,,1658
"Ann Arbor, MI",11460,1398.79,1814.2,1878.16,0.859529085,1697
"Blacksburg-Christiansburg-Radford, VA",13980,999.89,1812.78,1216.63,,1343
"Bremerton-Silverdale, WA",14740,1693.04,1783.08,1831.04,,1769
"Scranton--Wilkes-Barre, PA",42540,967.25,1774.33,1175.77,1.833073323,1306
"Winchester, VA-WV",49020,1282.29,1773.86,1599.37,5.690280695,1552
"Albany-Schenectady-Troy, NY",10580,1276.18,1754.92,1520.85,1.411984917,1517
"Kingston, NY",28740,1430.77,1753,1765.12,2.804327277,1650
"Orlando-Kissimmee-Sanford, FL",36740,1821.41,1750.2,1824.4,27.78099041,1799
"Salisbury, MD",41540,1176.22,1741.07,1630.77,,1516
"Olympia-Tumwater, WA",36500,1615.71,1734.43,1790.82,,1714
"Cape Coral-Fort Myers, FL",15980,1601.12,1721.31,1751.39,9.355610007,1691
"Eugene-Springfield, OR",21660,1186.19,1706.23,1705.58,16.81110294,1533
"Atlanta-Sandy Springs-Roswell, GA",12060,1754.97,1702.96,1674.46,,1711
"Asheville, NC",11700,1409.63,1701.7,1549.04,,1553
"Wenatchee, WA",48300,1201.36,1701.6,1755.59,,1553
"Pittsburgh, PA",38300,1113.01,1692.35,1353.28,,1386
"Fort Collins, CO",22660,1516.97,1687.3,1679.44,,1628
"Modesto, CA",33700,1341.45,1685.02,1698.96,19.47350494,1575
"Allentown-Bethlehem-Easton, PA",10900,1280.93,1684.34,1626.22,,1530`;
      Papa.parse(csvString, {
        header: true,
        skipEmptyLines: true,
        complete: function (results) {
          const data = results.data;

          const labels = [];
          const hudRents = [];
          const realPageRents = [];
          const zillowRents = [];
          const marketShareTicks = [];

          data.forEach((row, index) => {
            labels.push(row.City);
            hudRents.push(parseFloat(row.HUD));
            realPageRents.push(parseFloat(row.Realpage));
            zillowRents.push(parseFloat(row.Zillow));
            const share = Math.round(parseFloat(row.RealPageMarketShare) * 10) / 10;
            // Create "tick" marker as a scatter point with the x as the index and y as the share
            marketShareTicks.push({
              x: index,
              y: share
            });
          });

          const ctx = document.getElementById("rentComparablesChart").getContext("2d");
          new Chart(ctx, {
            type: "bar",
            data: {
              labels: labels,
              datasets: [
                {
                  label: "HUD Rent",
                  data: hudRents,
                  backgroundColor: "rgba(75, 192, 192, 0.6)",
                  yAxisID: "y"
                },
                {
                  label: "RealPage Rent",
                  data: realPageRents,
                  backgroundColor: "rgba(54, 162, 235, 0.6)",
                  yAxisID: "y"
                },
                {
                  label: "Zillow Rent",
                  data: zillowRents,
                  backgroundColor: "rgba(255, 206, 86, 0.6)",
                  yAxisID: "y"
                },
                {
                  label: "RealPage Market Share (%)",
                  type: "scatter",
                  data: marketShareTicks,
                  yAxisID: "y1",
                  showLine: false,
                  pointStyle: 'line',
                  pointRadius: 10,
                  pointBorderColor: "rgba(255, 99, 132, 1)",
                  pointBackgroundColor: "rgba(255, 99, 132, 1)",
                  pointBorderWidth: 2,
                  pointRotation: 0
                }
              ]
            },
            options: {
              responsive: true,
              plugins: {
                title: {
                  display: true,
                  text: "Rents and RealPage Market Share by City"
                },
                tooltip: {
                  callbacks: {
                    label: function (context) {
                      if (context.dataset.type === "scatter") {
                        return context.dataset.label + ": " + context.raw.y + "%";
                      } else {
                        return context.dataset.label + ": $" + context.parsed.y;
                      }
                    }
                  }
                }
              },
              scales: {
                x: {
                  title: { display: true, text: "City" },
                  ticks: { autoSkip: false },
                  offset: true
                },
                y: {
                  beginAtZero: true,
                  position: "left",
                  title: { display: true, text: "Rent (USD)" }
                },
                y1: {
                  beginAtZero: true,
                  position: "right",
                  title: { display: true, text: "RealPage Market Share (%)" },
                  grid: { drawOnChartArea: false }
                }
              }
            }
          });
        }
      });
    });

  </script>
  <script defer>
    document.addEventListener("DOMContentLoaded", function () {
      const yearBuiltCanvas = document.createElement("canvas");
      yearBuiltCanvas.id = "yearBuiltVolumeChart";
      document.querySelector("#identificationMethods").appendChild(yearBuiltCanvas);
  
      function aggregateUnitCountByYearBuilt(data) {
        const yearGroups = {};
        data.forEach(row => {
          // toss out rows with missing or invalid yearBuilt values or before 1900
          if (!row.yearBuilt || row.yearBuilt < 1920 || row.yearBuilt > 2025 ) return;

          const year = row.yearBuilt;
          const units = parseInt(row.unitcount) || 0;
          if (year) {
            if (!yearGroups[year]) yearGroups[year] = 0;
            yearGroups[year] += units;
          }
        });
        const sortedYears = Object.keys(yearGroups).sort();
        const counts = sortedYears.map(y => yearGroups[y]);
        return {
          labels: sortedYears,
          datasets: [
            {
              label: "Total Unit Count",
              data: counts,
              backgroundColor: "rgba(153, 102, 255, 0.6)",
              borderColor: "rgba(153, 102, 255, 1)",
              borderWidth: 1
            }
          ]
        };
      }
  
      function renderYearBuiltChart(data) {
        const chartData = aggregateUnitCountByYearBuilt(data);
        new Chart(document.getElementById("yearBuiltVolumeChart").getContext("2d"), {
          type: "bar",
          data: chartData,
          options: {
            responsive: true,
            plugins: {
              title: {
                display: true,
                text: "Unit Count by Year Built"
              },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    return "Units: " + context.parsed.y;
                  }
                }
              }
            },
            scales: {
              x: {
                title: { display: true, text: "Year Built" }
              },
              y: {
                beginAtZero: true,
                title: { display: true, text: "Total Units" }
              }
            }
          }
        });
      }
  
      fetch('https://rpc-webpage.s3-accelerate.amazonaws.com/cbsa_data.csv')
        .then(response => response.text())
        .then(csvText => {
          Papa.parse(csvText, {
            header: true,
            complete: function (results) {
              renderYearBuiltChart(results.data);
            }
          });
        })
        .catch(err => console.error("Error loading Year Built data:", err));
    });
  </script>
  
</body>

</html>