<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>RealPage Collusion Dashboard</title>
  <!-- Favicon -->
  <link rel="icon" type="image/png" href="photos/berkeleyischool-logo-vertical-blue-sm.png">
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
  <!-- Custom Styles -->
  <link rel="stylesheet" href="style.css" />
  <style>
    /* Sidebar styles */
    @media (min-width: 769px) {
      #sidebar-wrapper {
        position: fixed;
        top: 0;
        left: 0;
        height: 100vh;
        width: 250px;
      }
      #page-content-wrapper {
        margin-left: 250px;
      }
      #menu-toggle {
        display: none;
      }
      nav.navbar.fixed-top {
        display: none;
      }
    }
    /* Full-width content sections */
    .section {
      width: 100%;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      scroll-snap-align: start;
      transition: opacity 0.6s ease-out, transform 0.6s ease-out;
      opacity: 0;
      transform: translateY(30px);
      padding: 20px;
    }
    .section.in-view {
      opacity: 1;
      transform: translateY(0);
    }
    /* Adjusted chart container height for readability */
    canvas {
      width: 100% !important;
      height: 700px !important;
    }
  </style>
  <!-- Defer non-critical scripts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js" defer></script>
</head>
<body>
  <div class="d-flex" id="wrapper">
    <!-- Sidebar -->
    <div class="bg-light border-end" id="sidebar-wrapper">
      <div class="sidebar-heading text-center py-4">
        <img src="photos/berkeleyischool-logo-vertical-blue-sm.png" alt="UC Berkeley School of Information">
        <h2 class="mids-capstone">MIDS Capstone: <strong>RealPage Collusion Dashboard</strong></h2>
      </div>
      <div class="list-group list-group-flush">
        <a href="index.html" class="list-group-item list-group-item-action bg-light active">Homepage</a>
        <a href="about.html" class="list-group-item list-group-item-action bg-light">About</a>
        <a href="data-dictionary.html" class="list-group-item list-group-item-action bg-light">Data Dictionary</a>
        <a href="interactive-map.html" class="list-group-item list-group-item-action bg-light">Interactive Map</a>
        <a href="key-findings.html" class="list-group-item list-group-item-action bg-light">Key Findings</a>
        <a href="demo.html" class="list-group-item list-group-item-action bg-light">Try It Yourself: Interactive Modeling</a>
        <a href="contact-us.html" class="list-group-item list-group-item-action bg-light">Contact Us</a>
      </div>
      <div class="p-3">
        <a href="research-paper.pdf" target="_blank" class="btn btn-primary w-100">View Research Paper</a>
      </div>
    </div>
    <!-- /#sidebar-wrapper -->

    <!-- Page Content -->
    <div id="page-content-wrapper">
      <nav class="navbar navbar-expand-lg navbar-light bg-white border-bottom">
        <div class="container-fluid">
          <button class="btn btn-secondary" id="menu-toggle">MIDS Capstone, Spring 2025: RealPage Collusion Dashboard</button>
        </div>
      </nav>

      <!-- Introduction Section -->
      <section id="introduction" class="section in-view">
        <div class="text-center w-100">
          <h1>What is Rent, and What Are You Paying For?</h1>
          <img src="photos/intro.jpg" alt="Illustration of rent components" class="img-fluid" style="max-width: 80%; margin: 20px auto;">
          <p>
            Rent is more than just the monthly payment—it reflects the quality of your living space, its location, available amenities, and the competitive market forces at play.
            In this dashboard, we ask: <em>What is rent?</em> <br>
            <em>Why is your rent what it is?</em> <br>
            <em>Why does it vary so much across locations?</em> <br>
            And ultimately, <em>Is RealPage artificially inflating rent prices?</em>
          </p>
          <p>
            Explore the visual story as we break down these questions into data-driven insights.
          </p>
        </div>
      </section>      

      <div class="content">

        <!-- Section 1: What is Rent? -->
        <section id="whatIsRent" class="section">
          <div class="text-center w-100">
            <h1>What is Rent?</h1>
            <p>
              Rent represents the price you pay not only for shelter but also for a host of factors such as building quality, location, amenities, and the overall market demand.
              Here, we start by looking at the available supply—using the average unit count as a proxy—to give context to what shapes your living environment.
            </p>
            <canvas id="explanatoryChart"></canvas>
          </div>
        </section>

        <!-- Section 2: Why is Your Rent What It Is? -->
        <section id="diffinDiff" class="section">
          <div class="text-center w-100">
            <h1>Why is Your Rent What It Is?</h1>
            <p>
              The price of rent is influenced by market events and underlying economic factors.
              This Difference-in-Difference analysis uses the <strong>MPF-ANN-RENT-CHG</strong> metric—aggregated by building year—to show how rent changes over time, particularly before and after key market events.
            </p>
            <canvas id="diffinDiffChart"></canvas>
          </div>
        </section>

        <!-- Section 3: Why is Rent Different in Different Places? -->
        <section id="geoComparison" class="section">
          <div class="text-center w-100">
            <h1>Why Does Rent Vary by Location?</h1>
            <p>
              Local market dynamics, including demand, supply, and regional economic conditions, drive differences in rent.
              The Geographic Rent Index Comparison uses the <strong>MPF-RPSF</strong> metric (average rent per square foot) by state to illustrate how and why rents differ across regions.
            </p>
            <canvas id="geoChart"></canvas>
          </div>
        </section>

        <!-- Section 4: Is Rent Being Inflated? -->
        <section id="correlationTests" class="section">
          <div class="text-center w-100">
            <h1>Is RealPage Inflating Rent Prices?</h1>
            <p>
              The final and most critical question: Could rent prices be artificially inflated? By comparing historical ask rents via the <strong>MPF-HIST-ASK-RENT</strong> metric
              and correlating these values with known RealPage user data, we test whether there is a pattern that suggests collusion.
              Additional benchmark comparisons support this analysis.
            </p>
            <canvas id="correlationChart"></canvas>
          </div>
        </section>

        <!-- Supporting Section: Benchmark Comparison -->
        <section id="benchmarkComparison" class="section">
          <div class="text-center w-100">
            <h1>Benchmark Comparison</h1>
            <p>
              To further our case, we compare multifamily rent indices with single‑family benchmarks.
              This chart uses the <strong>MPF-RPSF</strong> field to show the average rent per square foot and highlights differences in market pricing.
            </p>
            <canvas id="benchmarkChart"></canvas>
          </div>
        </section>

        <!-- Supporting Section: Synthetic Control Robustness -->
        <section id="syntheticControl" class="section">
          <div class="text-center w-100">
            <h1>Robustness Check: Synthetic Control</h1>
            <p>
              As a robustness check, we use synthetic control methods with the <strong>MPF-HIST-ASK-RENT</strong> field to validate our findings across multiple markets.
            </p>
            <canvas id="syntheticChart"></canvas>
          </div>
        </section>

        <!-- Supporting Section: Alternative Rent Measures -->
        <section id="alternativeMeasures" class="section">
          <div class="text-center w-100">
            <h1>Alternative Rent Measures</h1>
            <p>
              We also explore alternative measures of rent using the <strong>unitcount</strong> field, providing another perspective on rent dynamics and further supporting our analysis.
            </p>
            <canvas id="alternativeChart"></canvas>
          </div>
        </section>

        <!-- Supporting Section: Identification of RealPage Buildings -->
        <section id="identificationMethods" class="section">
          <div class="text-center w-100">
            <h1>Identification of RealPage Buildings</h1>
            <p>
              Finally, we use the <strong>unitcount</strong> field to help identify buildings linked to RealPage,
              which assists in determining if certain groups are systematically associated with higher rent pricing.
            </p>
            <canvas id="identificationChart"></canvas>
          </div>
        </section>

      </div>

      <footer class="bg-light text-center py-3 border-top w-100">
        <p class="mb-0">
          &copy; 2025 RealPage Collusion Dashboard &mdash;
          <a href="privacy.html">View Full Privacy Policy</a>
        </p>
      </footer>
    </div>
    <!-- /#page-content-wrapper -->
  </div>

  <!-- Inline Script: Initialize Charts and Load Data -->
  <script defer>
    let charts = {};
    let csvData = [];
    // Track chart initialization per section
    let chartsInitialized = {
      whatIsRent: false,
      diffinDiff: false,
      benchmarkComparison: false,
      syntheticControl: false,
      alternativeMeasures: false,
      geoComparison: false,
      correlationTests: false,
      identificationMethods: false
    };

    // Mapping: labels include the CSV field name.
    const sectionMetrics = {
      whatIsRent: { metric: 'unitcount', label: 'Avg Unit Count (Field: unitcount)' },
      diffinDiff: { metric: 'MPF-ANN-RENT-CHG', label: 'Avg Annual Rent Change (Field: MPF-ANN-RENT-CHG)' },
      benchmarkComparison: { metric: 'MPF-RPSF', label: 'Avg Rent per Sq Ft (Field: MPF-RPSF)' },
      syntheticControl: { metric: 'MPF-HIST-ASK-RENT', label: 'Avg Historical Ask Rent (Field: MPF-HIST-ASK-RENT)' },
      alternativeMeasures: { metric: 'unitcount', label: 'Avg Unit Count (Alt.) (Field: unitcount)' },
      geoComparison: { metric: 'MPF-RPSF', label: 'Avg Rent per Sq Ft (Field: MPF-RPSF)' },
      correlationTests: { metric: 'MPF-HIST-ASK-RENT', label: 'Avg Historical Ask Rent (Field: MPF-HIST-ASK-RENT)' },
      identificationMethods: { metric: 'unitcount', label: 'Avg Unit Count (Field: unitcount)' }
    };

    // -------------------------------
    // New Helpers for Grouping by heroSource
    // -------------------------------
    // Define a simple color palette and helper to cycle through colors.
    const colorPalette = [
      'rgba(75, 192, 192, 1)',
      'rgba(255, 99, 132, 1)',
      'rgba(54, 162, 235, 1)',
      'rgba(255, 206, 86, 1)',
      'rgba(153, 102, 255, 1)',
      'rgba(255, 159, 64, 1)'
    ];
    let colorIndex = 0;
    function getNextColor() {
      const color = colorPalette[colorIndex % colorPalette.length];
      colorIndex++;
      return color;
    }

    // Aggregate CSV data by state grouped by heroSource (for bar charts)
    function aggregateByStateGrouped(metric) {
      let grouped = {};
      csvData.forEach(row => {
        let state = row.state;
        let hero = row.heroSource;
        if (state && hero) {
          if (!grouped[state]) grouped[state] = {};
          if (!grouped[state][hero]) grouped[state][hero] = { sum: 0, count: 0 };
          grouped[state][hero].sum += parseFloat(row[metric]) || 0;
          grouped[state][hero].count += 1;
        }
      });
      let labels = Object.keys(grouped).sort();
      // Get a unique list of heroSources
      let heroSet = new Set();
      Object.values(grouped).forEach(heroObj => {
        Object.keys(heroObj).forEach(hero => heroSet.add(hero));
      });
      let heroSources = Array.from(heroSet);
      let datasets = heroSources.map(hero => {
        let data = labels.map(state => {
          if (grouped[state][hero]) {
            let agg = grouped[state][hero];
            return agg.sum / agg.count;
          } else {
            return null;
          }
        });
        return {
          label: hero,
          data: data,
          fill: false,
          borderColor: getNextColor(),
          backgroundColor: 'transparent',
          tension: 0.1,
          borderWidth: 1
        };
      });
      return { labels, datasets };
    }

    // Aggregate CSV data by year grouped by heroSource (for line/scatter charts)
    function aggregateByYearGrouped(metric) {
      let grouped = {};
      csvData.forEach(row => {
        let year = row.yearBuilt;
        let hero = row.heroSource;
        if (year && hero) {
          if (!grouped[year]) grouped[year] = {};
          if (!grouped[year][hero]) grouped[year][hero] = { sum: 0, count: 0 };
          grouped[year][hero].sum += parseFloat(row[metric]) || 0;
          grouped[year][hero].count += 1;
        }
      });
      let labels = Object.keys(grouped).sort();
      let heroSet = new Set();
      Object.values(grouped).forEach(heroObj => {
        Object.keys(heroObj).forEach(hero => heroSet.add(hero));
      });
      let heroSources = Array.from(heroSet);
      let datasets = heroSources.map(hero => {
        let data = labels.map(year => {
          if (grouped[year][hero]) {
            let agg = grouped[year][hero];
            return agg.sum / agg.count;
          } else {
            return null;
          }
        });
        return {
          label: hero,
          data: data,
          fill: false,
          borderColor: getNextColor(),
          backgroundColor: 'transparent',
          tension: 0.1,
          borderWidth: 1
        };
      });
      return { labels, datasets };
    }

    // New function to choose the proper aggregation based on chart type.
    function getChartDataGrouped(metric, chartType) {
      if (chartType === 'line' || chartType === 'scatter') {
        return aggregateByYearGrouped(metric);
      } else {
        return aggregateByStateGrouped(metric);
      }
    }

    // -------------------------------
    // Updated initChart to work with grouped data
    // -------------------------------
    function initChart(ctxId, chartType, title, chartData, extraOptions = {}) {
      const ctx = document.getElementById(ctxId).getContext('2d');
      return new Chart(ctx, {
        type: chartType,
        data: {
          labels: chartData.labels,
          datasets: chartData.datasets
        },
        options: Object.assign({
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: 0 },
          interaction: { mode: 'index', intersect: false },
          plugins: {
            tooltip: { 
              enabled: true, 
              bodyFont: { size: 16 },
              callbacks: {
                label: function(context) {
                  if (chartType === 'scatter') {
                    return 'Year: ' + context.raw.x + ', Value: ' + context.raw.y;
                  } else {
                    return context.dataset.label + ": " + context.parsed.y;
                  }
                }
              }
            },
            legend: { display: true, labels: { font: { size: 16 } } },
            title: { display: true, text: title, font: { size: 18 } }
          },
          scales: {
            x: { ticks: { autoSkip: true, maxTicksLimit: 20, font: { size: 14 } } },
            y: { ticks: { font: { size: 14 } } }
          }
        }, extraOptions)
      });
    }

    // -------------------------------
    // Section Initialization (using grouped data)
    // -------------------------------
    function initializeSection(sectionId) {
      if (!chartsInitialized[sectionId]) {
        chartsInitialized[sectionId] = true;
        let metric = sectionMetrics[sectionId].metric;
        let chartType, dt;
        switch (sectionId) {
          case "whatIsRent":
            chartType = 'line';
            dt = getChartDataGrouped(metric, chartType);
            charts.whatIsRent = initChart('explanatoryChart', chartType, 'What is Rent? ' + sectionMetrics.whatIsRent.label, dt);
            break;
          case "diffinDiff":
            chartType = 'line';
            dt = getChartDataGrouped(metric, chartType);
            charts.diffinDiff = initChart('diffinDiffChart', chartType, 'Why is Your Rent What It Is? ' + sectionMetrics.diffinDiff.label, dt, {
              scales: {
                x: { title: { display: true, text: 'Year Built' }, ticks: { font: { size: 14 } } },
                y: { title: { display: true, text: 'MPF-ANN-RENT-CHG' }, ticks: { font: { size: 14 } } }
              }
            });
            break;
          case "benchmarkComparison":
            chartType = 'bar';
            dt = getChartDataGrouped(metric, chartType);
            charts.benchmark = initChart('benchmarkChart', chartType, 'Benchmark Comparison: ' + sectionMetrics.benchmarkComparison.label, dt);
            break;
          case "syntheticControl":
            chartType = 'line';
            dt = getChartDataGrouped(metric, chartType);
            charts.synthetic = initChart('syntheticChart', chartType, 'Synthetic Control: ' + sectionMetrics.syntheticControl.label, dt);
            break;
          case "alternativeMeasures":
            chartType = 'bar';
            dt = getChartDataGrouped(metric, chartType);
            charts.alternative = initChart('alternativeChart', chartType, 'Alternative Rent Measures: ' + sectionMetrics.alternativeMeasures.label, dt);
            break;
          case "geoComparison":
            chartType = 'line';
            dt = getChartDataGrouped(metric, chartType);
            charts.geo = initChart('geoChart', chartType, 'Geographic Rent Comparison: ' + sectionMetrics.geoComparison.label, dt);
            break;
          case "correlationTests":
            chartType = 'scatter';
            dt = getChartDataGrouped(metric, chartType);
            // For scatter charts, each dataset's data should be formatted as { x, y }
            dt.datasets.forEach((dataset, idx) => {
              dataset.data = dt.labels.map((year, i) => ({ x: parseFloat(year), y: dataset.data[i] }));
            });
            charts.correlation = initChart('correlationChart', chartType, 'Is Rent Being Inflated? ' + sectionMetrics.correlationTests.label, dt, {
              scales: {
                x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Year' } },
                y: { beginAtZero: true, title: { display: true, text: sectionMetrics.correlationTests.label } }
              },
              parsing: false
            });
            break;
          case "identificationMethods":
            chartType = 'bar';
            dt = getChartDataGrouped(metric, chartType);
            charts.identification = initChart('identificationChart', chartType, 'Identification Methods: ' + sectionMetrics.identificationMethods.label, dt);
            break;
        }
      }
    }

    // -------------------------------
    // CSV Data Aggregation for fallback (not used for grouped charts)
    // -------------------------------
    function aggregateByState() {
      // Legacy aggregation (not used with grouped charts)
      let stateAgg = {};
      csvData.forEach(row => {
        let state = row.state;
        if (state) {
          if (!stateAgg[state]) {
            stateAgg[state] = {
              unitcountSum: 0,
              mpfRpsfSum: 0,
              mpfHistAskRentSum: 0,
              mpfAnnRentChgSum: 0,
              count: 0
            };
          }
          stateAgg[state].unitcountSum += parseFloat(row.unitcount) || 0;
          stateAgg[state].mpfRpsfSum += parseFloat(row["MPF-RPSF"]) || 0;
          stateAgg[state].mpfHistAskRentSum += parseFloat(row["MPF-HIST-ASK-RENT"]) || 0;
          stateAgg[state].mpfAnnRentChgSum += parseFloat(row["MPF-ANN-RENT-CHG"]) || 0;
          stateAgg[state].count += 1;
        }
      });
    }

    function aggregateByYear() {
      // Legacy aggregation (not used with grouped charts)
      let yearAgg = {};
      csvData.forEach(row => {
        let year = row.yearBuilt;
        if (year) {
          if (!yearAgg[year]) {
            yearAgg[year] = { 
              unitcountSum: 0, 
              mpfRpsfSum: 0, 
              mpfHistAskRentSum: 0, 
              mpfAnnRentChgSum: 0, 
              count: 0 
            };
          }
          yearAgg[year].unitcountSum += parseFloat(row.unitcount) || 0;
          yearAgg[year].mpfRpsfSum += parseFloat(row["MPF-RPSF"]) || 0;
          yearAgg[year].mpfHistAskRentSum += parseFloat(row["MPF-HIST-ASK-RENT"]) || 0;
          yearAgg[year].mpfAnnRentChgSum += parseFloat(row["MPF-ANN-RENT-CHG"]) || 0;
          yearAgg[year].count += 1;
        }
      });
    }

    // -------------------------------
    // Update Charts if Data Changes (optional)
    // -------------------------------
    function updateAllCharts() {
      // This function can be extended if you want to refresh charts later.
    }

    // Use IntersectionObserver to initialize sections when they come into view.
    document.addEventListener("DOMContentLoaded", function() {
      const sections = document.querySelectorAll('.section');
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('in-view');
            initializeSection(entry.target.id);
          }
        });
      }, { threshold: 0.4 });
      sections.forEach(section => observer.observe(section));
    });

    // Load CSV data and perform aggregations.
    document.addEventListener("DOMContentLoaded", function() {
      fetch('https://rpc-webpage.s3-accelerate.amazonaws.com/cbsa_data.csv')
        .then(response => response.text())
        .then(csvText => {
          Papa.parse(csvText, {
            header: true,
            complete: function(results) {
              csvData = results.data;
              aggregateByState();
              aggregateByYear();
              updateAllCharts();
            }
          });
        })
        .catch(error => console.error("Error loading CSV data:", error));
    });

    // Sidebar toggle for mobile.
    document.addEventListener("DOMContentLoaded", function() {
      const menuToggle = document.getElementById("menu-toggle");
      const wrapper = document.getElementById("wrapper");
      menuToggle.addEventListener("click", () => {
        wrapper.classList.toggle("toggled");
      });
    });
  </script>
</body>
</html>
