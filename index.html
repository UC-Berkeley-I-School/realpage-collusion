<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>RealPage Collusion Dashboard</title>
  <!-- Favicon -->
  <link rel="icon" type="image/png" href="photos/berkeleyischool-logo-vertical-blue-sm.png">
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
  <!-- Custom Styles -->
  <link rel="stylesheet" href="style.css" />
  <style>
    /* Sidebar styles */
    @media (min-width: 769px) {
      #sidebar-wrapper {
        position: fixed;
        top: 0;
        left: 0;
        height: 100vh;
        width: 250px;
      }
      #page-content-wrapper {
        margin-left: 250px;
      }
      #menu-toggle {
        display: none;
      }
      nav.navbar.fixed-top {
        display: none;
      }
    }
    /* Full-width content sections */
    .section {
      width: 100%;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      scroll-snap-align: start;
      transition: opacity 0.6s ease-out, transform 0.6s ease-out;
      opacity: 0;
      transform: translateY(30px);
      padding: 20px;
    }
    .section.in-view {
      opacity: 1;
      transform: translateY(0);
    }
    /* Adjusted chart container height for readability */
    canvas {
      width: 100% !important;
      height: 700px !important;
    }
  </style>
  <!-- Defer non-critical scripts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js" defer></script>
</head>
<body>
  <div class="d-flex" id="wrapper">
    <!-- Sidebar -->
    <div class="bg-light border-end" id="sidebar-wrapper">
      <div class="sidebar-heading text-center py-4">
        <img src="photos/berkeleyischool-logo-vertical-blue-sm.png" alt="UC Berkeley School of Information">
        <h2 class="mids-capstone">MIDS Capstone: <strong>RealPage Collusion Dashboard</strong></h2>
      </div>
      <div class="list-group list-group-flush">
        <a href="index.html" class="list-group-item list-group-item-action bg-light active">Homepage</a>
        <a href="about.html" class="list-group-item list-group-item-action bg-light">About</a>
        <a href="data-dictionary.html" class="list-group-item list-group-item-action bg-light">Data Dictionary</a>
        <a href="interactive-map.html" class="list-group-item list-group-item-action bg-light">Interactive Map</a>
        <a href="key-findings.html" class="list-group-item list-group-item-action bg-light">Key Findings</a>
        <a href="demo.html" class="list-group-item list-group-item-action bg-light">Try It Yourself: Interactive Modeling</a>
        <a href="contact-us.html" class="list-group-item list-group-item-action bg-light">Contact Us</a>
      </div>
      <div class="p-3">
        <a href="research-paper.pdf" target="_blank" class="btn btn-primary w-100">View Research Paper</a>
      </div>
    </div>
    <!-- /#sidebar-wrapper -->

    <!-- Page Content -->
    <div id="page-content-wrapper">
      <nav class="navbar navbar-expand-lg navbar-light bg-white border-bottom">
        <div class="container-fluid">
          <button class="btn btn-secondary" id="menu-toggle">MIDS Capstone, Spring 2025: RealPage Collusion Dashboard</button>
        </div>
      </nav>

      <!-- Introduction Section -->
      <section id="introduction" class="section in-view">
        <div class="text-center w-100">
          <h1>What is Rent, and What Are You Paying For?</h1>
          <img src="photos/intro.jpg" alt="Illustration of rent components" class="img-fluid" style="max-width: 80%; margin: 20px auto;">
          <p>
            Rent is more than just the monthly payment—it reflects the quality of your living space, its location, available amenities, and the competitive market forces at play.
            In this dashboard, we ask: <em>What is rent?</em> <br>
            <em>Why is your rent what it is?</em> <br>
            <em>Why does it vary so much across locations?</em> <br>
            And ultimately, <em>Is RealPage artificially inflating rent prices?</em>
          </p>
          <p>
            Explore the visual story as we break down these questions into data-driven insights.
          </p>
        </div>
      </section>      

      <div class="content">

        <!-- Section 1: What is Rent? -->
        <section id="whatIsRent" class="section">
          <div class="text-center w-100">
            <h1>What is Rent?</h1>
            <p>
              Rent represents the price you pay not only for shelter but also for a host of factors such as building quality, location, amenities, and overall market demand.
              Here, we start by looking at the available supply—using the average unit count as a proxy—to give context to what shapes your living environment.
            </p>
            <canvas id="explanatoryChart"></canvas>
          </div>
        </section>

        <!-- Section 2: Why is Your Rent What It Is? -->
        <section id="diffinDiff" class="section">
          <div class="text-center w-100">
            <h1>Why is Your Rent What It Is?</h1>
            <p>
              The price of rent is influenced by market events and underlying economic factors.
              This Difference‑in‑Difference analysis uses the <strong>MPF‑ANN‑RENT‑CHG</strong> metric—aggregated by building year—to show how rent changes over time, particularly before and after key market events.
            </p>
            <canvas id="diffinDiffChart"></canvas>
          </div>
        </section>

        <!-- Section 3: Rent Comparison -->
        <section id="rentComparison" class="section">
          <div class="text-center w-100">
            <h1>Rent Comparison: Current vs Historical Ask Rent</h1>
            <p>
              This chart compares current rent (<strong>MPF‑RENT</strong>) with historical ask rent (<strong>MPF‑HIST‑ASK‑RENT</strong>) over time by heroSource.
              For each hero, the solid line represents current rent while the dashed line represents historical ask rent.
            </p>
            <canvas id="rentComparisonChart"></canvas>
          </div>
        </section>

        <!-- Section 4: Occupancy Trends -->
        <section id="occupancyTrends" class="section">
          <div class="text-center w-100">
            <h1>Occupancy Trends</h1>
            <p>
              This chart displays the occupancy rate (<strong>MPF‑OCC</strong>) over time, helping to reveal how property performance might relate to rent and market dynamics.
            </p>
            <canvas id="occupancyChart"></canvas>
          </div>
        </section>

        <!-- Section 5: Is Rent Being Inflated? -->
        <section id="correlationTests" class="section">
          <div class="text-center w-100">
            <h1>Is RealPage Inflating Rent Prices?</h1>
            <p>
              Could rent prices be artificially inflated? By comparing historical ask rents via the <strong>MPF‑HIST‑ASK‑RENT</strong> metric and correlating these values with known RealPage user data, we test for patterns suggesting collusion.
            </p>
            <canvas id="correlationChart"></canvas>
          </div>
        </section>

        <!-- Supporting Section: Benchmark Comparison -->
        <section id="benchmarkComparison" class="section">
          <div class="text-center w-100">
            <h1>Benchmark Comparison</h1>
            <p>
              To further our case, we compare multifamily rent indices with single‑family benchmarks.
              This chart uses the <strong>MPF‑RPSF</strong> field to show the average rent per square foot and highlights differences in market pricing.
            </p>
            <canvas id="benchmarkChart"></canvas>
          </div>
        </section>

        <!-- Supporting Section: Synthetic Control Robustness -->
        <section id="syntheticControl" class="section">
          <div class="text-center w-100">
            <h1>Robustness Check: Synthetic Control</h1>
            <p>
              As a robustness check, we use synthetic control methods with the <strong>MPF‑HIST‑ASK‑RENT</strong> field to validate our findings across multiple markets.
            </p>
            <canvas id="syntheticChart"></canvas>
          </div>
        </section>

        <!-- Supporting Section: Alternative Rent Measures -->
        <section id="alternativeMeasures" class="section">
          <div class="text-center w-100">
            <h1>Alternative Rent Measures</h1>
            <p>
              We also explore alternative measures of rent using the <strong>unitcount</strong> field, providing another perspective on rent dynamics and further supporting our analysis.
            </p>
            <canvas id="alternativeChart"></canvas>
          </div>
        </section>

        <!-- Supporting Section: Identification of RealPage Buildings -->
        <section id="identificationMethods" class="section">
          <div class="text-center w-100">
            <h1>Identification of RealPage Buildings</h1>
            <p>
              Finally, we use the <strong>unitcount</strong> field to help identify buildings linked to RealPage,
              which assists in determining if certain groups are systematically associated with higher rent pricing.
            </p>
            <canvas id="identificationChart"></canvas>
          </div>
        </section>

      </div>

      <footer class="bg-light text-center py-3 border-top w-100">
        <p class="mb-0">
          &copy; 2025 RealPage Collusion Dashboard &mdash;
          <a href="privacy.html">View Full Privacy Policy</a>
        </p>
      </footer>
    </div>
    <!-- /#page-content-wrapper -->
  </div>

  <!-- Inline Script: Initialize Charts and Load Data -->
  <script defer>
    let charts = {};
    let csvData = [];
    // Track chart initialization per section
    let chartsInitialized = {
      whatIsRent: false,
      diffinDiff: false,
      rentComparison: false,
      occupancyTrends: false,
      correlationTests: false,
      benchmarkComparison: false,
      syntheticControl: false,
      alternativeMeasures: false,
      identificationMethods: false
    };

    // Mapping: labels include the CSV field name or fields.
    const sectionMetrics = {
      whatIsRent: { metric: 'unitcount', label: 'Avg Unit Count (Field: unitcount)' },
      diffinDiff: { metric: 'MPF-ANN-RENT-CHG', label: 'Avg Annual Rent Change (Field: MPF-ANN-RENT-CHG)' },
      rentComparison: { metric1: 'MPF-RENT', metric2: 'MPF-HIST-ASK-RENT', label: 'Current Rent vs Historical Ask Rent' },
      occupancyTrends: { metric: 'MPF-OCC', label: 'Occupancy Rate (Field: MPF-OCC)' },
      correlationTests: { metric: 'MPF-HIST-ASK-RENT', label: 'Avg Historical Ask Rent (Field: MPF-HIST-ASK-RENT)' },
      benchmarkComparison: { metric: 'MPF-RPSF', label: 'Avg Rent per Sq Ft (Field: MPF-RPSF)' },
      syntheticControl: { metric: 'MPF-HIST-ASK-RENT', label: 'Avg Historical Ask Rent (Field: MPF-HIST-ASK-RENT)' },
      alternativeMeasures: { metric: 'unitcount', label: 'Avg Unit Count (Alt.) (Field: unitcount)' },
      identificationMethods: { metric: 'unitcount', label: 'Avg Unit Count (Field: unitcount)' }
    };

    // -------------------------------
    // New Helper for Determining Color by heroSource
    // -------------------------------
    function getColorForHero(hero) {
      if (hero.toLowerCase() === "realpage") {
        return 'rgba(54, 162, 235, 1)'; // blue
      } else if (hero.toLowerCase() === "google") {
        return 'rgba(255, 159, 64, 1)'; // orange
      } else {
        return 'rgba(128, 128, 128, 1)'; // grey
      }
    }

    // -------------------------------
    // Aggregate CSV data by state grouped by heroSource (for bar charts)
    // -------------------------------
    function aggregateByStateGrouped(metric) {
      let grouped = {};
      csvData.forEach(row => {
        let state = row.state;
        let hero = row.heroSource;
        if (state && hero) {
          if (!grouped[state]) grouped[state] = {};
          if (!grouped[state][hero]) grouped[state][hero] = { sum: 0, count: 0 };
          grouped[state][hero].sum += parseFloat(row[metric]) || 0;
          grouped[state][hero].count += 1;
        }
      });
      let labels = Object.keys(grouped).sort();
      let heroSet = new Set();
      Object.values(grouped).forEach(heroObj => {
        Object.keys(heroObj).forEach(hero => heroSet.add(hero));
      });
      let heroSources = Array.from(heroSet);
      let datasets = heroSources.map(hero => {
        let data = labels.map(state => {
          if (grouped[state][hero]) {
            let agg = grouped[state][hero];
            return agg.sum / agg.count;
          } else {
            return null;
          }
        });
        return {
          label: hero,
          data: data,
          fill: false,
          borderColor: getColorForHero(hero),
          backgroundColor: 'transparent',
          tension: 0.1,
          borderWidth: 1
        };
      });
      return { labels, datasets };
    }

    // -------------------------------
    // Aggregate CSV data by year grouped by heroSource (for line/scatter charts)
    // -------------------------------
    function aggregateByYearGrouped(metric) {
      let grouped = {};
      csvData.forEach(row => {
        let year = row.yearBuilt;
        let hero = row.heroSource;
        if (year && hero) {
          if (!grouped[year]) grouped[year] = {};
          if (!grouped[year][hero]) grouped[year][hero] = { sum: 0, count: 0 };
          grouped[year][hero].sum += parseFloat(row[metric]) || 0;
          grouped[year][hero].count += 1;
        }
      });
      let labels = Object.keys(grouped).sort();
      let heroSet = new Set();
      Object.values(grouped).forEach(heroObj => {
        Object.keys(heroObj).forEach(hero => heroSet.add(hero));
      });
      let heroSources = Array.from(heroSet);
      let datasets = heroSources.map(hero => {
        let data = labels.map(year => {
          if (grouped[year][hero]) {
            let agg = grouped[year][hero];
            return agg.sum / agg.count;
          } else {
            return null;
          }
        });
        return {
          label: hero,
          data: data,
          fill: false,
          borderColor: getColorForHero(hero),
          backgroundColor: 'transparent',
          tension: 0.1,
          borderWidth: 1
        };
      });
      return { labels, datasets };
    }

    // -------------------------------
    // New function to aggregate dual metrics by year grouped by heroSource
    // -------------------------------
    function aggregateDualByYearByHero(metric1, metric2) {
      let grouped = {};
      csvData.forEach(row => {
        let year = row.yearBuilt;
        let hero = row.heroSource;
        if (year && hero) {
          if (!grouped[year]) grouped[year] = {};
          if (!grouped[year][hero]) {
            grouped[year][hero] = { metric1Sum: 0, metric1Count: 0, metric2Sum: 0, metric2Count: 0 };
          }
          grouped[year][hero].metric1Sum += parseFloat(row[metric1]) || 0;
          grouped[year][hero].metric1Count += 1;
          grouped[year][hero].metric2Sum += parseFloat(row[metric2]) || 0;
          grouped[year][hero].metric2Count += 1;
        }
      });
      let years = Object.keys(grouped).sort();
      let heroSet = new Set();
      years.forEach(year => {
        for (let hero in grouped[year]) {
          heroSet.add(hero);
        }
      });
      let heroes = Array.from(heroSet);
      let datasets = [];
      heroes.forEach(hero => {
        let data1 = years.map(year => {
          if (grouped[year][hero]) {
            let group = grouped[year][hero];
            return group.metric1Sum / group.metric1Count;
          } else {
            return null;
          }
        });
        datasets.push({
          label: hero + " - Current Rent",
          data: data1,
          borderColor: getColorForHero(hero),
          fill: false,
          tension: 0.1,
          borderWidth: 1,
          borderDash: [] // solid line
        });
        let data2 = years.map(year => {
          if (grouped[year][hero]) {
            let group = grouped[year][hero];
            return group.metric2Sum / group.metric2Count;
          } else {
            return null;
          }
        });
        datasets.push({
          label: hero + " - Historical Ask Rent",
          data: data2,
          borderColor: getColorForHero(hero),
          fill: false,
          tension: 0.1,
          borderWidth: 1,
          borderDash: [5, 5] // dashed line
        });
      });
      return { labels: years, datasets };
    }

    // New function to choose the proper aggregation based on chart type.
    function getChartDataGrouped(metric, chartType) {
      if (chartType === 'line' || chartType === 'scatter') {
        return aggregateByYearGrouped(metric);
      } else {
        return aggregateByStateGrouped(metric);
      }
    }

    // -------------------------------
    // Updated initChart to work with grouped data
    // -------------------------------
    function initChart(ctxId, chartType, title, chartData, extraOptions = {}) {
      const ctx = document.getElementById(ctxId).getContext('2d');
      return new Chart(ctx, {
        type: chartType,
        data: {
          labels: chartData.labels,
          datasets: chartData.datasets
        },
        options: Object.assign({
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: 0 },
          interaction: { mode: 'index', intersect: false },
          plugins: {
            tooltip: { 
              enabled: true, 
              bodyFont: { size: 16 },
              callbacks: {
                label: function(context) {
                  if (chartType === 'scatter') {
                    return 'Year: ' + context.raw.x + ', Value: ' + context.raw.y;
                  } else {
                    return context.dataset.label + ": " + context.parsed.y;
                  }
                }
              }
            },
            legend: { display: true, labels: { font: { size: 16 } } },
            title: { display: true, text: title, font: { size: 18 } }
          },
          scales: {
            x: { ticks: { autoSkip: true, maxTicksLimit: 20, font: { size: 14 } } },
            y: { ticks: { font: { size: 14 } } }
          }
        }, extraOptions)
      });
    }

    // -------------------------------
    // Section Initialization (using grouped data)
    // -------------------------------
    function initializeSection(sectionId) {
      if (!chartsInitialized[sectionId]) {
        chartsInitialized[sectionId] = true;
        let chartType, dt;
        switch (sectionId) {
          case "whatIsRent":
            chartType = 'line';
            dt = getChartDataGrouped(sectionMetrics.whatIsRent.metric, chartType);
            charts.whatIsRent = initChart('explanatoryChart', chartType, 'What is Rent? ' + sectionMetrics.whatIsRent.label, dt);
            break;
          case "diffinDiff":
            chartType = 'line';
            dt = getChartDataGrouped(sectionMetrics.diffinDiff.metric, chartType);
            charts.diffinDiff = initChart('diffinDiffChart', chartType, 'Why is Your Rent What It Is? ' + sectionMetrics.diffinDiff.label, dt, {
              scales: {
                x: { title: { display: true, text: 'Year Built' }, ticks: { font: { size: 14 } } },
                y: { title: { display: true, text: 'MPF-ANN-RENT-CHG' }, ticks: { font: { size: 14 } } }
              }
            });
            break;
          case "rentComparison":
            chartType = 'line';
            dt = aggregateDualByYearByHero(sectionMetrics.rentComparison.metric1, sectionMetrics.rentComparison.metric2);
            charts.rentComparison = initChart('rentComparisonChart', chartType, sectionMetrics.rentComparison.label, dt);
            break;
          case "occupancyTrends":
            chartType = 'line';
            dt = getChartDataGrouped(sectionMetrics.occupancyTrends.metric, chartType);
            charts.occupancyTrends = initChart('occupancyChart', chartType, 'Occupancy Trends: ' + sectionMetrics.occupancyTrends.label, dt);
            break;
          case "correlationTests":
            chartType = 'scatter';
            dt = getChartDataGrouped(sectionMetrics.correlationTests.metric, chartType);
            dt.datasets.forEach((dataset, idx) => {
              dataset.data = dt.labels.map((year, i) => ({ x: parseFloat(year), y: dataset.data[i] }));
            });
            charts.correlation = initChart('correlationChart', chartType, 'Is Rent Being Inflated? ' + sectionMetrics.correlationTests.label, dt, {
              scales: {
                x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Year' } },
                y: { beginAtZero: true, title: { display: true, text: sectionMetrics.correlationTests.label } }
              },
              parsing: false
            });
            break;
          case "benchmarkComparison":
            chartType = 'bar';
            dt = getChartDataGrouped(sectionMetrics.benchmarkComparison.metric, chartType);
            charts.benchmark = initChart('benchmarkChart', chartType, 'Benchmark Comparison: ' + sectionMetrics.benchmarkComparison.label, dt);
            break;
          case "syntheticControl":
            chartType = 'line';
            dt = getChartDataGrouped(sectionMetrics.syntheticControl.metric, chartType);
            charts.synthetic = initChart('syntheticChart', chartType, 'Synthetic Control: ' + sectionMetrics.syntheticControl.label, dt);
            break;
          case "alternativeMeasures":
            chartType = 'bar';
            dt = getChartDataGrouped(sectionMetrics.alternativeMeasures.metric, chartType);
            charts.alternative = initChart('alternativeChart', chartType, 'Alternative Rent Measures: ' + sectionMetrics.alternativeMeasures.label, dt);
            break;
          case "identificationMethods":
            chartType = 'bar';
            dt = getChartDataGrouped(sectionMetrics.identificationMethods.metric, chartType);
            charts.identification = initChart('identificationChart', chartType, 'Identification Methods: ' + sectionMetrics.identificationMethods.label, dt);
            break;
        }
      }
    }

    function aggregateByState() {
      let stateAgg = {};
      csvData.forEach(row => {
        let state = row.state;
        if (state) {
          if (!stateAgg[state]) {
            stateAgg[state] = {
              unitcountSum: 0,
              mpfRpsfSum: 0,
              mpfHistAskRentSum: 0,
              mpfAnnRentChgSum: 0,
              count: 0
            };
          }
          stateAgg[state].unitcountSum += parseFloat(row.unitcount) || 0;
          stateAgg[state].mpfRpsfSum += parseFloat(row["MPF-RPSF"]) || 0;
          stateAgg[state].mpfHistAskRentSum += parseFloat(row["MPF-HIST-ASK-RENT"]) || 0;
          stateAgg[state].mpfAnnRentChgSum += parseFloat(row["MPF-ANN-RENT-CHG"]) || 0;
          stateAgg[state].count += 1;
        }
      });
    }

    function aggregateByYear() {
      let yearAgg = {};
      csvData.forEach(row => {
        let year = row.yearBuilt;
        if (year) {
          if (!yearAgg[year]) {
            yearAgg[year] = { 
              unitcountSum: 0, 
              mpfRpsfSum: 0, 
              mpfHistAskRentSum: 0, 
              mpfAnnRentChgSum: 0, 
              count: 0 
            };
          }
          yearAgg[year].unitcountSum += parseFloat(row.unitcount) || 0;
          yearAgg[year].mpfRpsfSum += parseFloat(row["MPF-RPSF"]) || 0;
          yearAgg[year].mpfHistAskRentSum += parseFloat(row["MPF-HIST-ASK-RENT"]) || 0;
          yearAgg[year].mpfAnnRentChgSum += parseFloat(row["MPF-ANN-RENT-CHG"]) || 0;
          yearAgg[year].count += 1;
        }
      });
    }

    function updateAllCharts() {
      // Optionally refresh charts if data changes.
    }

    document.addEventListener("DOMContentLoaded", function() {
      const sections = document.querySelectorAll('.section');
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('in-view');
            initializeSection(entry.target.id);
          }
        });
      }, { threshold: 0.4 });
      sections.forEach(section => observer.observe(section));
    });

    document.addEventListener("DOMContentLoaded", function() {
      fetch('https://rpc-webpage.s3-accelerate.amazonaws.com/cbsa_data.csv')
        .then(response => response.text())
        .then(csvText => {
          Papa.parse(csvText, {
            header: true,
            complete: function(results) {
              csvData = results.data;
              aggregateByState();
              aggregateByYear();
              updateAllCharts();
            }
          });
        })
        .catch(error => console.error("Error loading CSV data:", error));
    });

    document.addEventListener("DOMContentLoaded", function() {
      const menuToggle = document.getElementById("menu-toggle");
      const wrapper = document.getElementById("wrapper");
      menuToggle.addEventListener("click", () => {
        wrapper.classList.toggle("toggled");
      });
    });
  </script>
</body>
</html>